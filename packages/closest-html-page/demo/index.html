<!doctype html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>`closest-html-page` Demo</title>
		<style>
			fieldset + fieldset {
				margin-block-start: 1em;
			}

			fieldset > ul {
				display: block flex;
				gap: 1em;
				padding: 0;
			}

			fieldset > ul > li {
				display: inline flow-root;
			}

			input[type='url' i] {
				box-sizing: border-box;
				padding: 0.5em;
				inline-size: min(40em, 100%);
				font-family: initial;
				font-size: initial;
			}

			input[type='number' i] {
				box-sizing: border-box;
				padding: 0.5em;
				inline-size: 4em;
				font-family: initial;
				font-size: initial;
			}

			button {
				padding: 1em;
			}

			strong,
			output.undefined {
				background: #fff;
				color: #e00;
			}

			table {
				border-collapse: collapse;
			}

			th,
			td {
				border: 1px solid;
				padding: 0.5em;
			}

			dt {
				font-weight: 700;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"@w0s/closest-html-page": "../dist/index.js",
					"whatwg-mimetype": "https://esm.run/whatwg-mimetype@4.0.0"
				}
			}
		</script>
		<script type="module">
			import closestHTMLPage from '@w0s/closest-html-page';

			const inputBaseUrlElement = document.getElementById('input-baseurl');
			const inputMimeTextHtmlElement = document.getElementById('input-mime-text/html');
			const inputMimeTextXmlElement = document.getElementById('input-mime-text/xml');
			const inputMimeApplicationXmlElement = document.getElementById('input-mime-application/xml');
			const inputMimeApplicationXhtmlElement = document.getElementById('input-mime-application/xhtml+xml');
			const inputMimeImageSvgElement = document.getElementById('input-mime-image/svg+xml');
			const inputMaxFetchElement = document.getElementById('input-maxfetch');
			const inputFetchButtonElement = document.getElementById('input-fetch');

			const resultSuccessElement = document.getElementById('result-success');
			const resultErrorElement = document.getElementById('result-error');

			const outputFetchedResponseElement = document.getElementById('output-fetched-response');
			const outputUrlElement = document.getElementById('output-url');
			const outputTitleElement = document.getElementById('output-title');
			const outputErrorMessageElement = document.getElementById('output-error-message');

			inputFetchButtonElement.addEventListener('click', async () => {
				/* 表示リセット */
				resultSuccessElement.hidden = false;
				resultErrorElement.hidden = true;

				for (const liElement of outputFetchedResponseElement.parentNode?.querySelectorAll('li')) {
					liElement.remove();
				}
				outputUrlElement.value = '';
				outputUrlElement.className = '';
				outputTitleElement.value = '';
				outputTitleElement.className = '';
				outputErrorMessageElement.value = '';

				const mimeType = [];
				if (inputMimeTextHtmlElement.checked) {
					mimeType.push(inputMimeTextHtmlElement.value);
				}
				if (inputMimeTextXmlElement.checked) {
					mimeType.push(inputMimeTextXmlElement.value);
				}
				if (inputMimeApplicationXmlElement.checked) {
					mimeType.push(inputMimeApplicationXmlElement.value);
				}
				if (inputMimeApplicationXhtmlElement.checked) {
					mimeType.push(inputMimeApplicationXhtmlElement.value);
				}
				if (inputMimeImageSvgElement.checked) {
					mimeType.push(inputMimeImageSvgElement.value);
				}

				try {
					const { fetchedResponses, closestHTMLPageData } = await closestHTMLPage(inputBaseUrlElement.value, {
						maxFetchCount: Number(inputMaxFetchElement.value),
						mimeTypes: mimeType,
					});

					const fragment = document.createDocumentFragment();
					for (const fetchedResponse of fetchedResponses) {
						const templateElementClone = outputFetchedResponseElement.content.cloneNode(true);

						const liElement = templateElementClone.querySelector('li');
						liElement.textContent = (fetchedResponse.status === 200 ? '✔' : '✘') + ` [${fetchedResponse.status}] ${fetchedResponse.url}`;

						fragment.appendChild(templateElementClone);
					}
					outputFetchedResponseElement.parentNode?.appendChild(fragment);

					outputUrlElement.value = closestHTMLPageData?.url;
					outputUrlElement.className = closestHTMLPageData?.url === undefined ? 'undefined' : '';
					outputTitleElement.value = closestHTMLPageData?.title;
					outputTitleElement.className = closestHTMLPageData?.url === undefined ? 'undefined' : '';
				} catch (e) {
					resultSuccessElement.hidden = true;
					resultErrorElement.hidden = false;

					outputErrorMessageElement.value = e.message;
				}
			});
		</script>
		<meta property="og:title" content="Get the data of the HTML page of the nearest ancestor hierarchy" />
	</head>
	<body>
		<h1><code>closest-html-page</code> Demo</h1>

		<fieldset>
			<legend><label for="input-baseurl">Base URL</label></legend>
			<p>
				<input type="url" id="input-baseurl" value="https://saekitominaga.github.io/js-library-browser/packages/closest-html-page/demo/dir1/dir2/file" />
			</p>
		</fieldset>

		<fieldset>
			<legend>
				<label for="input-maxfetch">Max <code>fetch()</code> count</label>
			</legend>

			<p>
				* If no HTML page matching the condition can be retrieved after this number of attempts to access the ancestor hierarchy, the process is rounded up
				(<code>0</code> = ∞).
			</p>
			<p><input type="number" min="0" id="input-maxfetch" value="3" /></p>
		</fieldset>

		<fieldset>
			<legend>MIME types of the HTML resource to retrieve</legend>

			<ul>
				<li>
					<label><input type="checkbox" value="text/html" checked="" id="input-mime-text/html" />text/html</label>
				</li>
				<li>
					<label><input type="checkbox" value="text/xml" id="input-mime-text/xml" />text/xml</label>
				</li>
				<li>
					<label><input type="checkbox" value="application/xml" id="input-mime-application/xml" />application/xml</label>
				</li>
				<li>
					<label><input type="checkbox" value="application/xhtml+xml" checked="" id="input-mime-application/xhtml+xml" />application/xhtml+xml</label>
				</li>
				<li>
					<label><input type="checkbox" value="image/svg+xml" id="input-mime-image/svg+xml" />image/svg+xml</label>
				</li>
			</ul>
		</fieldset>

		<p><button type="button" id="input-fetch">Fetch</button></p>
		<p>
			<strong>
				⚠ If the reference URL has a deep hierarchy and the maximum number of attempts is large (or 0 is specified), hitting the button repeatedly will result
				in a large number of <code>fetch()</code> operations.</strong
			>
		</p>

		<section>
			<h2>Acquisition result</h2>

			<div id="result-success">
				<section>
					<h3>The URL where the <code>fetch()</code> operation was performed</h3>
					<ul>
						<template id="output-fetched-response">
							<li></li>
						</template>
					</ul>
				</section>
				<section>
					<h3>HTML page of the nearest ancestor hierarchy</h3>
					<dl>
						<div>
							<dt>URL</dt>
							<dd><output id="output-url"></output></dd>
						</div>
						<div>
							<dt>Title</dt>
							<dd><output id="output-title"></output></dd>
						</div>
					</dl>
				</section>
			</div>
			<div id="result-error">
				<strong>
					<output id="output-error-message"></output>
				</strong>
			</div>
		</section>
	</body>
</html>
